name: Deploy to Production

on:
  push:
    tags: ['v*']
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true

env:
  ENVIRONMENT: production
  CLUSTER: production-cluster
  NAMESPACE: testrails-prod

jobs:
  validate:
    name: Pre-deployment validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ghcr.io/${{ github.repository }}/backend:${{ github.event.inputs.image_tag || github.ref_name }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: validate
    environment:
      name: production
      url: https://app.testrails.example.com
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER }} --region us-east-1

      - name: Create backup before deployment
        run: |
          # Create database backup
          BACKUP_NAME="testrails-prod-backup-$(date +%Y%m%d-%H%M%S)"
          kubectl exec -n ${{ env.NAMESPACE }} deployment/postgres -- \
            pg_dumpall -U postgres | aws s3 cp - s3://testrails-backups/${BACKUP_NAME}.sql
          echo "BACKUP_NAME=${BACKUP_NAME}" >> $GITHUB_ENV

      - name: Set image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "backend_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "frontend_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            # Extract version from tag (e.g., v1.0.0 -> 1.0.0)
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "backend_tag=${VERSION}" >> $GITHUB_OUTPUT
            echo "frontend_tag=${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to Kubernetes (blue-green)
        run: |
          # Check current active deployment
          ACTIVE=$(kubectl get service backend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.version}')

          # Set target version
          TARGET=$( [ "$ACTIVE" = "blue" ] && echo "green" || echo "blue" )

          # Deploy new version to inactive color
          kubectl set image deployment/backend-${TARGET} \
            backend=ghcr.io/${{ github.repository }}/backend:${{ steps.tag.outputs.backend_tag }} \
            -n ${{ env.NAMESPACE }}

          kubectl set image deployment/frontend-${TARGET} \
            frontend=ghcr.io/${{ github.repository }}/frontend:${{ steps.tag.outputs.frontend_tag }} \
            -n ${{ env.NAMESPACE }}

      - name: Wait for new version rollout
        run: |
          # Determine target version
          ACTIVE=$(kubectl get service backend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.version}')
          TARGET=$( [ "$ACTIVE" = "blue" ] && echo "green" || echo "blue" )

          kubectl rollout status deployment/backend-${TARGET} -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/frontend-${TARGET} -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Run database migrations
        run: |
          # Determine target version
          ACTIVE=$(kubectl get service backend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.version}')
          TARGET=$( [ "$ACTIVE" = "blue" ] && echo "green" || echo "blue" )

          kubectl exec -n ${{ env.NAMESPACE }} deployment/backend-${TARGET} -- \
            python manage.py migrate --noinput

      - name: Smoke tests on new version
        run: |
          # Determine target version
          ACTIVE=$(kubectl get service backend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.version}')
          TARGET=$( [ "$ACTIVE" = "blue" ] && echo "green" || echo "blue" )

          # Port-forward to test new version
          kubectl port-forward -n ${{ env.NAMESPACE }} svc/backend-${TARGET} 8080:80 &
          PF_PID=$!
          sleep 5

          # Run smoke tests
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/api/status || exit 1

          kill $PF_PID

      - name: Switch traffic to new version
        run: |
          # Determine target version
          ACTIVE=$(kubectl get service backend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.version}')
          TARGET=$( [ "$ACTIVE" = "blue" ] && echo "green" || echo "blue" )

          # Update service selector
          kubectl patch service backend -n ${{ env.NAMESPACE }} -p '{"spec":{"selector":{"version":"'${TARGET}'"}}}'
          kubectl patch service frontend -n ${{ env.NAMESPACE }} -p '{"spec":{"selector":{"version":"'${TARGET}'"}}}'

      - name: Health check on production
        run: |
          # Wait for traffic switch
          sleep 30

          # Check production health
          kubectl run healthcheck-prod --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -f https://app.testrails.example.com/health || exit 1

          kubectl run healthcheck-api --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -f https://app.testrails.example.com/api/status || exit 1

      - name: Create GitHub release
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          body: |
            ## Production Deployment
            - **Version:** ${{ github.ref_name }}
            - **Backend Image:** ghcr.io/${{ github.repository }}/backend:${{ steps.tag.outputs.backend_tag }}
            - **Frontend Image:** ghcr.io/${{ github.repository }}/frontend:${{ steps.tag.outputs.frontend_tag }}
            - **Backup:** ${{ env.BACKUP_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify deployment status
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment for TestRails: ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_DEPLOYMENTS }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_DEPLOYMENTS }}
